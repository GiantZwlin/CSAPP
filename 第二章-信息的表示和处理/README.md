# 第二章 信息的处理和表示

---
### 寻址和字节顺序
#### 大端法和小端法
> 最高有效字节在最前面的叫做大端法

> 最低有效字节在在最前面的叫做小端法

---
> 使用show_bytes函数可以把数据的内部表示暴露出来,参考show_byte.c文件

### 补码和无符号数的转换
> 正权和负权的想法
> 对于正数(设有w位),补码和无符号数是一样的,负数的补码转无符号数加上2的w次即可

### C语言中的有符号数和无符号数
> 当执行一个运算时,如果它的一个运算数十有符号的二另一个是无符号的,那么C语言会隐式的将有符号参数强制转换成无符号数,并假设两个数都是非负的

---
### 扩展一个数的位表示
> 无符号数的零扩展
> 补码数的符号扩展
> **16进制数字8到F的最高有效位为1**
---

### 截断数字

> 截断无符号数x为k位,即对2的k次取余即可

> 截断补码数为k位时,先当成无符号数进行截断,然后在将无符号数转成补码即可
---

## 整数运算
> *阿贝尔群*的概念,模数加法就是阿贝尔群

### 无符号加法
> 无符号数加法十分简单,如果不发生溢出,那么直接x+y即可,如果发生溢出,直接截断即可,判断无符号数加法是否溢出,只要考虑和是不是比二者都小,如果变小了,那么就发生了溢出

### 补码加法
> 补码加法的情况较为复杂,会发生正溢出或者负溢出,但同样是截断即可,负溢和变正,正溢和变负

> 习题2.30 与 习题2.32看代码部分注释

### 补码的非(补码的加法逆元)

> 前面已经提到,补码加法构成一个阿贝尔群,那么每个数x都有其加法的逆元-x,对于不是INT_MIN的数来说,其逆元就是-x,而*INT_MIN的逆元为它本身*.
>> 补码的非的两种快速求法 
> * 对于补码的位级表示而言,其逆元就是每位取反再加1.
> * 从右往左,第一个1之后的所有位全部取反(第一个1不取反)

### 无符号乘法

> 十分简单,相乘截断即可

### 补码乘法

> 补码乘法截断后的结果与把其当做无符号数计算时总是一样的

### 乘/除以常数
> 补码在乘或除以常数是,会使用移位运算来加速乘法的进行,因为在CPU内部往往乘法和除法较之移位运算要慢很多.

> 在乘以常数的位运算优化中,类似快速幂的思想,同时直接左移即可

> 在除以常数的位运算优化中,在除2的k次幂时,同时,除法只能够优化除以2的幂次的情况,而不能像乘法一样优化任何常数,**算数右移采用的是向下舍入,与实际想法,故而需要使用偏置技术,来使之向上舍入**.具体做法是如果右移k位,先在原数上加上(2的k次减一),在执行算数右移,具体原理参见书P73页,与之相对的C表达式为:
>> ( x<0 ? x+( 1<<k )-1 : x ) >> k 

> 习题2.42参见div16.c文件(仅使用移位计算完成除法)

> 各种情况下都要**主动考虑INT_MIN的情况**

---
## 浮点数

### 二进制小数

